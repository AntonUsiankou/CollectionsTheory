

1. Дайте неформальное определение контейнера.  
**Ответ.** Коллекциями/контейнерами в Java принято называть классы, основная цель которых – хранить набор других элементов.  
**Источник.** https://javarush.ru/quests/lectures/questsyntax.level08.lecture01
   
2. Дайте определение коллекции в java.  
**Ответ.** Коллекции — это хранилища или контейнеры, поддерживающие различные способы накопления и упорядочения объектов с целью обеспечения возможностей эффективного доступа к ним.  
**Источник.**  Java. Методы программирования : уч.-мет. пособие / И.Н. Блинов, В.С. Романчик. —254c.

3. Какой имеется в java контейнер, отличный от коллекций?
Дайте ему определение.  
**Ответ.** Map отличный от колеекций. Карта отображений — это объект, который хранит пару «ключ–значение». Соттветственно, некоторые методы интерфейса Collection нельзя использовать в Map.  
**Источник.** Java. Методы программирования : уч.-мет. пособие / И.Н. Блинов, В.С. Романчик. —275c.
https://jsehelper.blogspot.com/2016/01/java-collections-framework-1.html


4. Дайте определение Collections framework?  
**Ответ.** Группа отдельных элементов, сформированная по некоторым правилам. Класс List хранит элементы в порядке вставки, в классе Set нельзя хранить повторяющиеся элементы, а класс Queue выдает элементы в порядке, определяемом спецификацией очереди.
**Источник.** Философия Java.Библиотека программитса 4-е изд.-Б.Эккель-280с.

5. Какие разделы содержит Collections framework?
Определите их, и для чего они предназначены?  
**Ответ.** Вся система Collection Framework может быть разделена на три составляющих:
1) Набор базовых интерфейсов для нексольких типов коллекций
2) Набор классов для реализации базовых интерфейсов с разными «потребительскими» характеристиками
3) Набор алгоритмов для работы с коллекциями  
**Источник.** http://java-course.ru/begin/collections_01


6. В чем преимущества использования Collections Framework.  
**Ответ.** Java Collections Framework есть следующие преимущества:
• Требует меньше усилий.Фреймворк располагает множеством распространенных типов коллекций и полезных методов для манипуляции данными. Таким образом, мы можем сосредоточиться на бизнес-логике, а не разработке наших API.
• Отличное качество— использование хорошо проверенных коллекций увеличивает качество нашей программы.
• Повторное использование и совместимость  
**Источник.** https://javadevblog.com/obzor-kollektsiy-v-java-java-collections-framework.html


7. Является ли антипаттерном следующее объявление ссылки на коллекцию?
Collection collection;
Если да, то как называется антипаттерн и исправьте объявление ссылки.  
**Ответ.** Да является. Необходимо объявлять интерфейсную параметризированную ссылку. Например:
List<Student> student=new ArrayList<>();

8. К каким негативным последствиям может привести использование raw types?
Приведите пример.  
**Ответ.** Необработанный тип - это имя универсального класса или интерфейса без каких-либо аргументов типа. Например, учитывая общий класс Box:
```java
Public class Box <T> {
public void set (T t) {/ * ... * /}
// ...
}
```
Необработанные типы отображаются в устаревшем коде, потому что многие классы API (например, классы коллекций) не были универсальными до JDK 5.0. При использовании необработанных типов вы, по сути, получаете поведение до дженериков - Box дает вам Object.
Если вы назначите необработанный тип параметризованному типу, вы получите предупреждение:
```java
Box rawBox = new Box();           // rawBox is a raw type of Box<T>
Box<Integer> intBox = rawBox;     // warning: unchecked conversion
Вы также получите предупреждение, если используете необработанный тип для вызова универсальных методов, определенных в соответствующем универсальном типе:
Box<String> stringBox = new Box<>();
Box rawBox = stringBox;
rawBox.set(8);  // warning: unchecked invocation to set(T)
```
Предупреждение показывает, что необработанные типы обходят проверки универсального типа, откладывая обнаружение небезопасного кода во время выполнения. Следовательно, вам следует избегать использования необработанных типов.  
**Источник.** https://docs.oracle.com/javase/tutorial/java/generics/rawTypes.html

9. Почему допускаются raw types с коллекциями?  
**Ответ.** Есть всего три случая, когда использовать обобщенный тип без параметра правильно:
• Целевая версия Java < 5.0 (2002 год и ранее – вряд ли это ваш случай);
• В литерале класса. List<String>.class не сработает, нужно писать List.class;
• В операторе instanceof. Вместо instanceof Set<Integer> должно быть instanceof Set.  
**Источник.** https://itsobes.ru/JavaSobes/kogda-nuzhno-ispolzovat-raw-types/

10. Какое главное назначение раздела Интерфейсы?
Другими словами, если известен интерфейс коллекции, то что это дает программисту?  
**Ответ.** Интерфейсы основных коллекций инкапсулируют различные типы коллекций. Интерфейсы позволяют манипулировать коллекциями независимо от деталей их представления.  
**Источник.** https://docs.oracle.com/javase/tutorial/collections/interfaces/index.html

11. Какое главное назначение раздела Имплементации?
Другими словами, если известна имплементация, то что это дает программисту?  
**Ответ.** Реализации - это объекты данных, используемые для хранения коллекций, которые реализуют интерфейсы.
Реализации общего назначения - это наиболее часто используемые реализации, предназначенные для повседневного использования. Они сведены в таблицу, озаглавленную "Реализации общего назначения".
Специальные реализации предназначены для использования в особых ситуациях и демонстрируют нестандартные характеристики производительности, ограничения использования или поведение. Параллельные реализации предназначены для поддержки высокого уровня параллелизма, как правило, за счет однопоточной производительности. Эти реализации являются частью пакета java.util.concurrent.
Реализации оболочки используются в сочетании с другими типами реализаций, часто универсальными, для обеспечения дополнительных или ограниченных функциональных возможностей.
Удобные реализации - это мини-реализации, обычно доступные через статические фабричные методы, которые предоставляют удобные и эффективные альтернативы универсальным реализациям для специальных коллекций (например, одноэлементных наборов).
Абстрактные реализации - это скелетные реализации, которые облегчают создание пользовательских реализаций, описанных далее в разделе «Пользовательские реализации коллекций».   
**Источник.** https://docs.oracle.com/javase/tutorial/collections/implementations/index.html
   
12. Приведите иерархию интерфейсов коллекций.  
**Ответ.**
```java        
           Set;                           
Collection List;               MapSortedMap;
           Queue;
            Deque
```            
Источник. https://docs.oracle.com/javase/tutorial/collections/interfaces/index.html

13. Какие существуют способы прохода (traversing) по коллекции до версии java 8 (т.е. от версии 5 до версии 7 включительно)?  
**Ответ.** Существует три способа прохода по коллекции:
(1) с использованием агрегатных операций
(2) с конструкцией for-each
(3) с использованием итераторов.  
**Источник.** https://docs.oracle.com/javase/tutorial/collections/interfaces/collection.html


14. Приведите идиомы для следующей коллекции:
Collection<Entity> entities = …;

15. Какой способ является более подходящим для прохода по коллекции до версии java 8?  
**Ответ.** В JDK 8 и более поздних версиях предпочтительным методом итерации по коллекции является получение потока и выполнение с ним агрегатных операций. Агрегатные операции часто используются в сочетании с лямбда-выражениями, чтобы сделать программирование более выразительным, используя меньше строк кода. Следующий код последовательно перебирает набор фигур и распечатывает красные объекты:
myShapesCollection.stream()
.filter(e -> e.getColor() == Color.RED)
.forEach(e -> System.out.println(e.getName()));  
**Источник.** https://docs.oracle.com/javase/tutorial/collections/interfaces/collection.html\

16. Реализация какого интерфейса позволяет коллекциям использоваться в конструкции for-each?
Какой метод этого интерфейса обеспечивает данную возможность?  
**Ответ.** java.lang.Iterable.
Если мы используем коллекции (java.util.Collection), благодаря этому получаем точно и Iterable.
Если объект имеет класс, реализующий Iterable, он обязуется предоставлять при вызове метода iterator некий Итератор, который будет выполнять итерацию по содержимому этого объекта.  
**Источник.** https://javarush.ru/groups/posts/1983-for-i-for-each-loop---skaz-o-tom-kak-ja-iterirovalsja-iterirovalsja-da-ne-vihiterirovalsja

17. Что такое итератор?  
**Ответ.** Итератор—это объект, обеспечивающий перемещение по последовательности объектов с выбором каждого объекта этой последовательности, при этом программисту-клиенту не надо знать или заботиться о лежащей в ее основе структуре.  
**Источник.**  Философия Java.Библиотека программитса 4-е изд.-Б.Эккель-288с.

18. Дана коллекция из n элементов.
Сколько в ней существует возможных позиций курсора итератора?
Ответ.

19. Какие методы объявлены в интерфейсе Iterator<E>?
Охарактеризуйте их.  
**Ответ.**
```java    
public interface Iterator<E> {
boolean hasNext();
E next();
void remove(); //optional
}
```
Метод hasNext возвращает true, если итерация содержит больше элементов, а метод next возвращает следующий элемент в итерации. Метод remove удаляет последний элемент, который был возвращен next из базовой Collection. Метод remove может быть вызван только один раз за вызов next и выдает исключение, если это правило нарушается.  
**Источник.** https://docs.oracle.com/javase/tutorial/collections/interfaces/collection.html

20. В каких случаях следует явно использовать итератор вместо for-each?  
**Ответ.** Используйте Iterator вместо конструкции for-each, когда вам нужно:

    - Удалить текущий элемент. Конструкция for-each скрывает итератор, поэтому вы не можете вызвать remove. Следовательно, конструкция for-each не может использоваться для фильтрации.
    - Параллельный перебор нескольких коллекций.  
**Источник.** https://docs.oracle.com/javase/tutorial/collections/interfaces/collection.html


21. Пусть условие удаления элемента из коллекции Collection<Entity> entities задается методом isRemoved() класса Entity. 
Приведите идиому удаления элементов этой коллекции.

22. Какие группы методов (или операций) объявлены в интерфейсе Collection 
(до java 8)?
Какие методы входят в каждую группу?
23. В чем разница методов Object[] toArray(), <T> T[] toArray(T[] a) интерфейса Collection?  
**Ответ.**
Object[] toArray()— копирует элементы коллекции в массив объектов;
T[] toArray(T a[])— копирует элементы коллекции в массив объектов определенного типа.  
**Источник.** Java. Методы программирования : уч.-мет. пособие / И.Н. Блинов, В.С. Романчик. —255с.

24. В описании методов интерфейсов коллекций в JavaDoc есть методы, помеченные фразой “optional operation”.

Modifier and Type
Method and Description
boolean
add(E e)
Ensures that this collection contains the specified element (optional operation).
boolean
addAll(Collection<? extends E> c)
Adds all of the elements in the specified collection to this collection (optional operation).
Void
clear()
Removes all of the elements from this collection (optional operation).

Как это понимать?   
**Ответ.** "Необязательный" в коллекции означает, что класс реализации не должен "реализовывать" (в соответствии с терминологией выше), а он просто бросает NotSupportedException).
Хороший пример - add() метод для неизменных коллекций - конкретный будет просто реализовать метод, который ничего не делает, кроме метания NotSupportedException
В случае Collection это делается для предотвращения беспорядочных деревьев наследования, что сделает программистов убогими, но в большинстве случаев эта парадигма не рекомендуется, и их следует избегать, если это возможно.  
**Источник.** https://overcoder.net/q/43457/%D0%BD%D0%B5%D0%BE%D0%B1%D1%8F%D0%B7%D0%B0%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D1%8B%D0%B5-%D0%BC%D0%B5%D1%82%D0%BE%D0%B4%D1%8B-%D0%B2-%D0%B8%D0%BD%D1%82%D0%B5%D1%80%D1%84%D0%B5%D0%B9%D1%81%D0%B5-java

25. Какую математическую сущность моделирует интерфейс Set?  
**Ответ.** Set-это Коллекция, которая не может содержать повторяющиеся элементы. Он моделирует абстракцию математического множества.  
**Источник.** https://docs.oracle.com/javase/tutorial/collections/interfaces/set.html


26. Какое основное свойство всех имплементаций интерфейса Set, т.е. что их объединяет независимо от имплементации?  
**Ответ.** Интерфейс Set содержит только методы, унаследованные от Collection, и добавляет ограничение, запрещающее дублирование элементов. Set также добавляет более строгий контракт на поведение операций equals и hashCode, позволяя осмысленно сравнивать экземпляры Set, даже если их типы реализации различаются. Два экземпляра Set равны, если они содержат одинаковые элементы.  
**Источник.** https://docs.oracle.com/javase/tutorial/collections/interfaces/set.html

27. Может ли множество содержать null элемент?  
**Ответ.** В пустой TreeMap можно положить единственный ключ-null, все остальные операции (кроме size() и clear(), кстати) после этого не работают. В непустой TreeMap положить null-ключ нельзя из-за обязательного вызова compareTo().  
**Источник.** https://habr.com/ru/post/164027/


28. Есть ли отношение следования (предыдущий, текущий, следующий элемент) в множестве?
Если нет, то есть ли у множества итератор?  
**Ответ.** Платформа Java содержит три реализации Set общего назначения: HashSet, TreeSet и LinkedHashSet. HashSet, который хранит свои элементы в хеш-таблице, является наиболее эффективной реализацией; однако он не дает никаких гарантий относительно порядка итерации.
iterator()-Функция получения итератора коллекции.  
**Источник.** https://docs.oracle.com/javase/tutorial/collections/interfaces/set.html


29. Как получить элемент множества по индексу?  
**Ответ.** Множество, как и список, и любую коллекцию (и не только) можно обойти в цикле for-each:
```java    
for (Integer number : intSet) {
System.out.println(number);
}
```
Но вот доступ по индексу (порядковому номеру) (метод list.get(int index)) есть только у List, у Set этого метода нет. Это связано с тем, что порядок элементов во множестве не определён.
LinkedHashSet хоть и позволяет обходить элементы в порядке их добавления, но доступ к n-ому элементу потребовал бы обхода всех предыдущих элементов. Множества просто не предназначены для непоследовательного («случайного») доступа (random access). При необходимости позиционного доступа можно скопировать содержимое множества в список: new ArrayList(someSet).  
**Источник.** https://javanese.online/%D0%BE%D1%81%D0%BD%D0%BE%D0%B2%D1%8B_JVM-%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F/%D1%81%D1%82%D0%B0%D0%BD%D0%B4%D0%B0%D1%80%D1%82%D0%BD%D0%B0%D1%8F_%D0%B1%D0%B8%D0%B1%D0%BB%D0%B8%D0%BE%D1%82%D0%B5%D0%BA%D0%B0_Java/sets/

30. Как реализован метод add() во множестве?  
**Ответ.** Метод add добавляет указанный элемент в Set, если он еще не присутствует, и возвращает логическое значение, указывающее, был ли добавлен элемент.  
**Источник.**  https://docs.oracle.com/javase/tutorial/collections/interfaces/set.html

    31. Какая группа методов увеличилась в интерфейсе Set по сравнению с интерфейсом Collection?
Какие методы добавились?  
**Ответ.** containsAll(Collection c)- Проверка присутсвия коллекции в наборе. Возвращает true, если все элементы содержатся в наборе.
retainAll(Collection c)- Удаление элементов, не принадлежащих переданной коллекции.
removeAll(Collection c)-Удаление из набора всех элементов переданной коллекции.  
**Источник.** http://java-online.ru/java-set.xhtml



32. Зависит ли множество, как структура данных, от имплементации?
Обоснуйте ответ.



33. Какие методы должны быть переопределены в классе, которым параметризовано множество, чтобы гарантировать правильную работу HashSet имплементации?  
**Ответ.** Класс Object имеет метод hashCode(), который используется классом HashSet для эффективного размещения объектов, заносимых в коллекцию. В классах объектов, заносимых в HashSet, этот метод должен быть переопределен ( override ).  
**Источник.** http://www.javable.com/tutorials/fesunov/lesson11/

34. Какие соглашения установлены для переопределения метода hashCode()?  
**Ответ.**
Соглашение между equals и hashCode в Java
1) Если объекты равны по результатам выполнения метода equals, тогда их hashcode должны быть одинаковыми.
2) Если объекты не равны по результатам выполнения метода equals, тогда их hashcode могут быть как одинаковыми, так и разными. Однако для повышения производительности, лучше, чтобы разные объекты возвращали разные коды.  
**Источник.** https://javarush.ru/groups/posts/1340-peregruzka-metodov-equals-i-hashcode-v-java

35. Почему недостаточно переопределить один только метод hashCode()?  
**Ответ.** Так как HashMap и HashTable в Java полагаются на методы equals() и hashCode() для сравнения своих key и values.
Вы должны переопределить hashCode() в каждом классе, который переопределяет equals(). Несоблюдение этого требования приведет к нарушению общего договора для Object.hashCode(), что предотвратит правильное функционирование вашего класса в сочетании со всеми коллекциями на основе хешей, включая HashMap, HashSet и Hashtable.  
**Источник.** https://javarush.ru/groups/posts/1340-peregruzka-metodov-equals-i-hashcode-v-java
Дж.Блох,Эффективное программирование на Java.

36. Являются ли приведенная реализация hashCode() допустимой (в смысле будут ли правильно выполняться все операции над множеством)?
@Override
public int hashCode() {
return 22;
}  
**Ответ.** Данная реализация не допустима.

37. Являются ли приведенная реализация hashCode() допустимой (в смысле будут ли правильно выполняться все операции над множеством HashSet<Entity>)?
```java
class Entity {
private int value;
public int getValue() {
return value;
}
public void setValue(int value) {
this.value = value;
}
@Override
public boolean equals(Object obj) {
if (this == obj) return true;
if (obj == null || getClass() != obj.getClass()) return false;
Entity entity = (Entity) obj;
return value == entity.value;
}
@Override
public int hashCode() {
int result = 1;
result = result * 31 + value;
return result;
}
}
```  
**Ответ.** Данная реализация правильная. Все операции над множеством будут выполняться верно.

38. Какие методы должны быть переопределены в классе, которым параметризовано множество, чтобы гарантировать правильную работу TreeSet имплементации?  
**Ответ.** Методы equals и hashCode. экземпляр TreeSet выполняет все сравнения элементов, используя свой метод compareTo (или compare)  
**Источник.** https://docs.oracle.com/javase/7/docs/api/java/util/TreeSet.html

39. В чем заключается актуальность внешнего компаратора?  
**Ответ.** перед нами может возникнуть проблема, что если разработчик не реализовал в своем классе, который мы хотим использовать, интерфейс Comparable, либо реализовал, но нас не устраивает его функциональность, и мы хотим ее переопределить? На этот случай есть еще более гибкий способ, предполагающий применение интерфейса Comparator<E>.  
**Источник.** https://metanit.com/java/tutorial/5.6.php

40. Дана следующая коллекция:
Collection<Entity> entities = …;
Приведите идиому, позволяющую оставить только уникальные элементы в коллекции при условии правильной реализации класса Entity.

41. Какую математическую сущность моделирует интерфейс List?  
**Ответ.** Список - это упорядоченная коллекция (иногда называемая последовательностью). Списки могут содержать повторяющиеся элементы.  
**Источник.**  https://docs.oracle.com/javase/tutorial/collections/interfaces/list.html

42. Какое основное свойство всех имплементаций интерфейса List, т.е. что их объединяет независимо от имплементации?  
**Ответ.** Пользователь этого интерфейса имеет точный контроль над тем, где в списке будет вставлен каждый элемент. Пользователь может получить доступ к элементам по их целочисленному индексу (позиции в списке) и искать элементы в списке.  
**Источник.** https://docs.oracle.com/javase/8/docs/api/java/util/List.html5

43. Может ли имплементация интерфейса List содержать одинаковые элементы?
Обоснуйте ответ.  
**Ответ.** В отличие от наборов, списки обычно допускают повторяющиеся элементы. Более формально списки обычно допускают пары элементов e1 и e2, такие как e1.equals (e2), и они обычно допускают несколько нулевых элементов, если они вообще разрешают нулевые элементы.  
**Источник.** https://docs.oracle.com/javase/8/docs/api/java/util/List.html

44. Какие группы методов увеличились в интерфейсе List по сравнению с интерфейсом Collection?
Какие методы добавились?  
**Ответ.** Интерфейс List предоставляет специальный итератор, называемый ListIterator, который позволяет вставку и замену элементов, а также двунаправленный доступ в дополнение к обычным операциям, которые предоставляет интерфейс Iterator. Предоставляется метод для получения итератора списка, который начинается с указанной позиции в списке. Интерфейс List предоставляет два метода поиска указанного объекта. С точки зрения производительности эти методы следует использовать с осторожностью. Во многих реализациях они будут выполнять дорогостоящий линейный поиск. Интерфейс List предоставляет два метода для эффективной вставки и удаления нескольких элементов в произвольной точке списка.  
**Источник.** https://docs.oracle.com/javase/8/docs/api/java/util/List.html

45. Влияют ли изменения внесенные в последовательность, возвращаемый методом subList(), на исходную последовательность?  
**Ответ.** Нет не влияет. Операция представления диапазона, subList (int fromIndex, int toIndex), возвращает представление списка части этого списка, чьи индексы находятся в диапазоне от fromIndex включительно до toIndex, исключая.   
**Источник.** https://docs.oracle.com/javase/tutorial/collections/interfaces/list.html

46. Дана следующая последовательность:
List<Entity> entities = …;
Приведите идиому, позволяющую удалить все элементы с номерами из полусегмента [fromIndex; toIndex).  
**Ответ.** entities.subList(fromIndex, toIndex).clear();  
**Источник.** https://docs.oracle.com/javase/tutorial/collections/interfaces/list.html


47. Дана следующая неупорядоченная последовательность и некоторый элемент для сравнения:
List<Entity> entities = …;
Entity cmpEntity = …;
Приведите идиому для выполнения метода void doAction() класса Entity со всеми элементами последовательности entities, которые совпадают с элементом cmpEntity.
Запрещается упорядочивать последовательность и явно проверять на равенство каждый элемент последовательности.

48. Какую математическую сущность моделирует интерфейс Queue?  
**Ответ.** Коллекция, предназначенная для хранения элементов перед обработкой. Очереди обычно, но не обязательно, упорядочивают элементы по принципу FIFO (first-in-first-out).  
**Источник.** https://docs.oracle.com/javase/8/docs/api/java/util/Queue.html

49. Какое основное свойство всех имплементаций интерфейса Queue, т.е. что их объединяет независимо от имплементации?  
**Ответ.** Реализации очереди обычно не позволяют вставлять нулевые элементы. Реализации очередей обычно не определяют основанные на элементах версии методов equals и hashCode, а вместо этого наследуют основанные на идентификаторах версии от Object.  
**Источник.** https://docs.oracle.com/javase/tutorial/collections/interfaces/queue.html

50. Какие группы методов увеличились в интерфейсе Queue по сравнению с интерфейсом Collection?
Какие методы добавились?  
**Ответ.** Помимо основных операций Collection, очереди предоставляют дополнительные операции вставки, извлечения и проверки. Каждый из этих методов существует в двух формах: один выдает исключение в случае сбоя операции, другой возвращает специальное значение (либо null, либо false, в зависимости от операции). Последняя форма операции вставки разработана специально для использования с реализациями Queue с ограниченной емкостью; в большинстве реализаций операции вставки не могут завершиться ошибкой.

51. Какую математическую сущность моделирует интерфейс Deque?  
**Ответ.** Обычно произносится как deck, deque - это двусторонняя очередь.  
**Источник.** https://docs.oracle.com/javase/tutorial/collections/interfaces/deque.html



52. Какое основное свойство всех имплементаций интерфейса Deque, т.е. что их объединяет независимо от имплементации?  
**Ответ.** Двусторонняя очередь - это линейный набор элементов, который поддерживает вставку и удаление элементов в обеих конечных точках.  
**Источник.** https://docs.oracle.com/javase/tutorial/collections/interfaces/deque.html

53. Какие методы определяет Deque в добавок к методам унаследованным от Queue?  
**Ответ.** Методы, представленные в интерфейсе Deque, разделены на три части:
-Методы addfirst и offerFirst вставляют элементы в начало экземпляра Deque. Методы addLast и offerLast вставляют элементы в конец экземпляра Deque. Когда емкость экземпляра Deque ограничена, предпочтительными методами являются offerFirst и offerLast, поскольку addFirst может не сгенерировать исключение, если он заполнен.
-Методы removeFirst и pollFirst удаляют элементы из начала экземпляра Deque. Методы removeLast и pollLast удаляют элементы с конца. Методы pollFirst и pollLast возвращают null, если Deque пуст, тогда как методы removeFirst и removeLast выдают исключение, если экземпляр Deque пуст.
-Методы getFirst и peekFirst получают первый элемент экземпляра Deque. Эти методы не удаляют значение из экземпляра Deque. Точно так же методы getLast и peekLast извлекают последний элемент. Методы getFirst и getLast генерируют исключение, если экземпляр deque пуст, тогда как методы peekFirst и peekLast возвращают NULL.  
**Источник.** https://docs.oracle.com/javase/tutorial/collections/interfaces/deque.html

54. Верно ли утверждение, что Queue всегда обрабатывает элемента в порядке FIFO?  
**Ответ.** Очереди обычно, но не обязательно, упорядочивают элементы по принципу FIFO (first-in-first-out).  
**Источник.** https://docs.oracle.com/javase/8/docs/api/java/util/Queue.html

55. Какой элемент независимо от упорядочения Queue будет удален методами remove и poll?  
**Ответ.** Какой бы порядок ни использовался, заголовок очереди - это элемент, который будет удален вызовом remove или poll.  
**Источник.** https://docs.oracle.com/javase/tutorial/collections/interfaces/queue.html

56. Зачем в интерфейсе Queue метод poll, когда есть remove?  
**Ответ.**
E poll() — возвращает и удаляет головной элемент очереди, возвращает null, если очередь пуста;
E remove()— возвращает и удаляет головной элемент очереди.
Методы element() и remove() отличаются от методов peek() и poll() тем, что генерируют исключение NoSuchElementException, если очередь пуста.  
**Источник.** Java. Методы программирования : уч.-мет. пособие / И.Н. Блинов, В.С. Романчик. —268с.



57. Какую математическую сущность моделирует интерфейс Map?  
**Ответ.** Он моделирует абстракцию математической функции.  
**Источник.** https://docs.oracle.com/javase/tutorial/collections/interfaces/map.html

58. Какое основное свойство всех имплементаций интерфейса Map, т.е. что их объединяет независимо от имплементации?  
**Ответ.** Карта - это объект, который сопоставляет ключи значениям. Карта не может содержать повторяющиеся ключи: каждый ключ может соответствовать не более чем одному значению.  
**Источник.** https://docs.oracle.com/javase/tutorial/collections/interfaces/map.html

59. Реализует ли Map интерфейс Collection?  
**Ответ.** Нет не реализует.

60. Какую структуру данных представляет собой совокупность.
    • ключей;
    • значений;
    • пар ключ-значение
любой имплементации Map?  
**Ответ.** Map — это структура данных, которая содержит набор пар “ключ-значение”. По своей структуре данных напоминает словарь, поэтому ее часто так и называют.  
**Источник.** https://javarush.ru/groups/posts/2542-otvetih-na-samihe-populjarnihe-voprosih-ob-interfeyse-map

61. Какие группы операций определены в интерфейсе Map?  
**Ответ.** Интерфейс карты включает методы для основных операций (таких как put, get, remove, containsKey, containsValue, size и empty), массовых операций (таких как putAll и clear) и представлений коллекций (таких как keySet, entrySet и values) .  
**Источник.** https://docs.oracle.com/javase/tutorial/collections/interfaces/map.html

62. Какой интерфейс представляет мультикарту (multimap) в Collections Framework?  
**Ответ.** Multimap похожа на Map, но может сопоставлять каждый ключ с несколькими значениями. Платформа Java Collections Framework не включает интерфейс для мультиотображений, потому что они используются не так часто. Довольно просто использовать карту, значения которой являются экземплярами списка, в качестве мульти-карты.  
**Источник.** https://docs.oracle.com/javase/tutorial/collections/interfaces/map.html

63. Дана карта:
Map<K, V> map = …;
Приведите идиому для выполнения метода void doAction(K key, V value) со всеми элементами карты.

64. Дана карта:
Map<K, V> map = …;
в которой нет элементов со значением null.
Приведите идиому для выполнения метода void doAction(V value) с элементом map, заданным ключом K key.

65. Дана карта:
Map<K, V> map = …;
в которой есть элементы со значением null.
Приведите идиому для выполнения метода void doAction(V value) с элементом map, заданным ключом K key.

66. Можно ли отрефакторить следующий код?
Если да, то сделайте это.
Purchase purchase = new Purchase("meat", new Byn(100), 10);
for (Map.Entry<Purchase, WeekDay> entry: purchaseWeekDayMap.entrySet()) {
if (entry.getKey().equals(purchase)) {
System.out.println(entry.getKey());
break;
}
}

67. Что возвращает метод put интерфейса Map?  
**Ответ.** V put(K key, V value)— помещает ключ key и значение value в вызывающую карту. При добавлении в карту элемента с существующим ключом произойдет замена текущего элемента новым. При этом метод возвратит заменяемый элемент;  
**Источник.** Java. Методы программирования : уч.-мет. пособие / И.Н. Блинов, В.С. Романчик. —276с.


68. Почему интерфейс Map не расширяет интерфейс Collection в Java Collections Framework?  
**Ответ.** Map - пара ключ/значение, тогда как Collection представляет собой набор группы объектов, хранящихся в структурированном виде, и имеет определенный механизм доступа. Причина, по которой карта не расширяет интерфейс Collections, заключается в том, что add(E e); не поддерживает пару ключевых значений, например Map put(K, V).  
**Источник.** https://overcoder.net/q/544206/%D0%BF%D0%BE%D1%87%D0%B5%D0%BC%D1%83-map-%D0%BD%D0%B5-%D1%80%D0%B0%D1%81%D1%88%D0%B8%D1%80%D1%8F%D0%B5%D1%82-%D0%B8%D0%BD%D1%82%D0%B5%D1%80%D1%84%D0%B5%D0%B9%D1%81-collection-duplicate

69. Дайте определение понятию имплементация (Implementation) в контексте Collections Framework.  
**Ответ.** Реализации, имплементация: это конкретные реализации интерфейсов коллекций. По сути, это многократно используемые структуры данных.  
**Источник.** https://docs.oracle.com/javase/tutorial/collections/intro/index.html

70. Какие виды имплементаций можно выделить?  
**Ответ.** Динамический массив,Список,Очередь,Стэк,Карта,Множество.  
**Источник.** https://docs.oracle.com/javase/tutorial/collections/interfaces/index.html

71. На что влияет выбор имплементации?  
**Ответ.** Выбор имплементации влияет на то, как будут хранится элементы в коллекции.

72. Идиома создания пустой коллекции имеет следующий вид:
SomeInterface<Entity> entities = new SuitableImplementation<>();
Почему в левой части идиомы используется ссылка на интерфейс, а не на имплементацию?  
**Ответ.** Для того чтобы в будущем,если будет такая необходимость,можно было поменять имплементацию и не переписывать код.

73. Укажите наиболее часто используемые имплементации для интерфейсов Collections Framework, а также структуру данных, которая поддерживается данной имплементацией. 
Результат представьте в виде таблицы:
Interface     Implementation     Abstract Data Type
-----------------------------------------------------------------------

74. Приведите идиому создания очереди.
Xxx<Integer> queue = ...;
Xxx - это подходящий интерфейс.
Добавьте 3 элемента и удалите 1, выведя содержимое на консоль.

75. Приведите идиому создания стека. 
Xxx<Integer> stack = ...;
Xxx - это подходящий интерфейс.
Добавьте 3 элемента и удалите 1, выведя содержимое на консоль.

76. Когда целесообразно использовать реализацию TreeSet вместо HashSet?  
**Ответ.** HashSet, который хранит свои элементы в хэш-таблице, является наиболее эффективной реализацией; однако он не дает никаких гарантий относительно порядка итерации. TreeSet, который хранит свои элементы в красно-черном дереве, упорядочивает свои элементы на основе их значений; он значительно медленнее, чем HashSet.  
**Источник.** https://docs.oracle.com/javase/tutorial/collections/interfaces/set.html

77. Опишите неупорядоченные реализации Map.  
**Ответ.** Hashtable — реализация такой структуры данных, как хэш-таблица. Она не позволяет использовать null в качестве значения или ключа. Эта коллекция была реализована раньше, чем Java Collection Framework, но в последствии была включена в его состав. Как и другие коллекции из Java 1.0, Hashtable является синхронизированной (почти все методы помечены как synchronized). Из-за этой особенности у неё имеются существенные проблемы с производительностью и, начиная с Java 1.2, в большинстве случаев рекомендуется использовать другие реализации интерфейса Map ввиду отсутствия у них синхронизации.

HashMap — коллекция является альтернативой Hashtable. Двумя основными отличиями от Hashtable являются то, что HashMap не синхронизирована и HashMap позволяет использовать null как в качестве ключа, так и значения. Так же как и Hashtable, данная коллекция не является упорядоченной: порядок хранения элементов зависит от хэш-функции. Добавление элемента выполняется за константное время O(1), но время удаления, получения зависит от распределения хэш-функции. В идеале является константным, но может быть и линейным O(n). Более подробную информацию о HashMap можно почитать здесь (актуально для Java < 8).  
**Источник.** https://habr.com/ru/post/237043/

78. Опишите упорядоченные реализации Map.  
**Ответ.** LinkedHashMap — это упорядоченная реализация хэш-таблицы. Здесь, в отличии от HashMap, порядок итерирования равен порядку добавления элементов. Данная особенность достигается благодаря двунаправленным связям между элементами (аналогично LinkedList). Но это преимущество имеет также и недостаток — увеличение памяти, которое занимет коллекция. Более подробная информация изложена в этой статье.

TreeMap — реализация Map основанная на красно-чёрных деревьях. Как и LinkedHashMap является упорядоченной. По-умолчанию, коллекция сортируется по ключам с использованием принципа "natural ordering", но это поведение может быть настроено под конкретную задачу при помощи объекта Comparator, который указывается в качестве параметра при создании объекта TreeMap.  
**Источник.** https://habr.com/ru/post/237043/

79. Чем отличается ArrayList и LinkedList?  
**Ответ.** ArrayList—Как можно догадаться из названия, его реализация основана на обычном массиве.
LinkedList — Особенностью реализации данной коллекции является то, что в её основе лежит двунаправленный связный список (каждый элемент имеет ссылку на предыдущий и следующий).  
**Источник.** https://habr.com/ru/post/237043/

80. Что такое вычислительная сложность операции (алгоритма)?  
**Ответ.** Сложность алгоритмов обычно оценивают по времени выполнения или по используемой памяти. В обоих случаях сложность зависит от размеров входных данных: массив из 100 элементов будет обработан быстрее, чем аналогичный из 1000. При этом точное время мало кого интересует: оно зависит от процессора, типа данных, языка программирования и множества других параметров. Важна лишь асимптотическая сложность, т. е. сложность при стремлении размера входных данных к бесконечности.
Допустим, некоторому алгоритму нужно выполнить 4n3+ 7n условных операций, чтобы обработать n элементов входных данных. При увеличении n на итоговое время работы будет значительно больше влиять возведение n в куб, чем умножение его на 4 или же прибавление 7n. Тогда говорят, что временная сложность этого алгоритма равна О(n3), т. е. зависит от размера входных данных кубически.
Использование заглавной буквы О (или так называемая О-нотация) пришло из математики, где её применяют для сравнения асимптотического поведения функций. Формально O(f(n)) означает, что время работы алгоритма (или объём занимаемой памяти) растёт в зависимости от объёма входных данных не быстрее, чем некоторая константа, умноженная на f(n).  
**Источник.** https://tproger.ru/articles/computational-complexity-explained/

81. Укажите вычислительную сложность для операций получения элемента по индексу, поиска, вставки и удаления, для основных коллекций.
Ответ.

82. В чем разница между интерфейсами Comparable и Comparator?  
**Ответ.** Принципиальное различие в том, что в Comparable "зашит" один-единственный алгоритм сравнения объектов, в то время как Comparator представляет собой внешнюю заменяемую настройку.
Архитектурно, Comparable - это интерфейс значения, в то время как Comparator - настройка контейнера.
Следует использовать Comparable в том случае, когда задается естественный (наиболее логичный) порядок. Например, для строк это регистрозависимое лексикографическое сравнение, а для длинных чисел - сравнение по значению.
Во всех остальных случаях - без отдельного компаратора не обойтись.  
**Источник.** https://ru.stackoverflow.com/questions/639143/%D0%92-%D1%87%D0%B5%D0%BC-%D1%80%D0%B0%D0%B7%D0%BD%D0%B8%D1%86%D0%B0-%D0%BC%D0%B5%D0%B6%D0%B4%D1%83-comparable-%D0%B8-comparator

83. В чем разница между Iterator и ListIterator?  
**Ответ.** Итератор - это суперкласс ListIterator.


Вот различия между ними:

С iterator вы можете перемещаться только вперед, но с помощью ListIterator вы можете перемещать назад и при чтении элементов.
С ListIterator вы можете получить индекс в любой точке при обходе, что невозможно при использовании iterator s.
С iterator вы можете проверить только наличие следующего элемента или нет, но в ListIterator вы можете проверить предыдущий и следующий элементы.
С помощью ListIterator вы можете добавить новый элемент в любой момент времени, пройдя по нему. Невозможно с iterator.
С помощью ListIterator вы можете изменять элемент во время перемещения, что невозможно при использовании iterator.  
**Источник.** https://progi.pro/raznica-mezhdu-iterator-i-listiterator-1893643

84. Почему в классе Iterator нет метода для получения следующего элемента без передвижения курсора?  
**Ответ.** Он может быть реализован поверх текущего интерфейса Iterator, но так как его использование будет редким, нет смысла включать его в интерфейс, который должен реализовать каждый.  
**Источник.** https://coderlessons.com/articles/java/40-java-kollektsii-interviu-voprosy-i-otvety

85. Назовите высокопроизводительные реализации Set для перечислимых типов (enum)?  
**Ответ.** Абстрактный класс EnumSet> наследуется от абстрактного класса AbstractSet. java.util.AbstractCollection java.util.AbstractSet java.util.EnumSet Класс специально реализован для работы с типами enum. Все элементы такой коллекции должны принадлежать единственному типу enum, определенному явно или неявно.  
**Источник.** Java. Методы программирования : уч.-мет. пособие / И.Н. Блинов, В.С. Романчик. —274с.


86. Как происходит удаление элементов из ArrayList? Как меняется в этом случае размер ArrayList?  
**Ответ.** При удалении произвольного элемента из списка, все элементы находящиеся «правее» смещаются на одну ячейку влево и реальный размер массива (его емкость, capacity) не изменяется никак. Механизм автоматического «расширения» массива существует, а вот автоматического «сжатия» нет, можно только явно выполнить «сжатие» командой trimToSize().  
**Источник.** https://coderlessons.com/articles/java/40-java-kollektsii-interviu-voprosy-i-otvety

87. Можно ли использовать массив в качестве ключа для HashMap?
Если да, то какие есть особенности.  
**Ответ.** Хеш-код массива не зависит от хранимых в нем элементов, а присваивается при создании массива (метод вычисления хеш-кода массива не переопределен и вычисляется по стандартному Object.hashCode() на основании адреса массива). Так же у массивов не переопределен equals и выполняет сравнение указателей. Это приводит к тому, что обратиться к сохраненному с ключом-массивом элементу не получится при использовании другого массива такого же размера и с такими же элементами, доступ можно осуществить лишь в одном случае — при использовании той же самой ссылки на массив, что использовалась для сохранения элемента.  
**Источник.** https://habr.com/ru/post/162017/

88. Где определены полиморфные алгоритмы для работы с коллекциями? Опишите основные группы.

89. В чем заключается назначение метода
Collections.unmodifiableCollection(Collection<? extends T> c)?

90. Перечислите различия между массивами и коллекциями?  
**Ответ.** Существует 5 различий между массивом и коллекцией, как показано ниже :
1) Массивы фиксированы по размеру, в то время как некоторые коллекции могут расти по своей природе.
2) Массивы хранят однородные данные. Коллекции хранят как однородные, так и разнородные данные.
3) В массивах нет подчеркивающих структур данных, в то время как коллекции имеют подчеркивающие структуры данных.
4) Массивы рекомендуются для повышения производительности, а коллекции-нет.
5) Массивы используют больше места в памяти по сравнению с коллекциями.  
**Источник.**https://overcoder.net/q/31547/%D0%BF%D0%BE%D1%87%D0%B5%D0%BC%D1%83-%D0%BC%D0%B0%D1%81%D1%81%D0%B8%D0%B2%D1%8B-%D0%BA%D0%BE%D0%B2%D0%B0%D1%80%D0%B8%D0%B0%D0%BD%D1%82%D0%BD%D1%8B-%D0%B0-%D0%B4%D0%B6%D0%B5%D0%BD%D0%B5%D1%80%D0%B8%D0%BA%D0%B8-%D0%B8%D0%BD%D0%B2%D0%B0%D1%80%D0%B8%D0%B0%D0%BD%D1%82%D0%BD%D1%8B

91. Массивы и коллекции являются ковариантными или инвариантными?
Поясните ответ.  
**Ответ.**
  Массивы отличаются от типичного типа двумя важными способами. Первые массивы ковариантны. Дженерики являются инвариантными.
  Ковариант просто означает, что если X является подтипом Y, тогда X [] также будет подтипом Y []. Массивы являются ковариантными. Поскольку string является подтипом Object So
String[] is subtype of Object[]
Инвариантно просто означает независимо от того, что X является подтипом Y или нет,
List<X> will not be subType of List<Y>.  
**Источник.** https://overcoder.net/q/31547/%D0%BF%D0%BE%D1%87%D0%B5%D0%BC%D1%83-%D0%BC%D0%B0%D1%81%D1%81%D0%B8%D0%B2%D1%8B-%D0%BA%D0%BE%D0%B2%D0%B0%D1%80%D0%B8%D0%B0%D0%BD%D1%82%D0%BD%D1%8B-%D0%B0-%D0%B4%D0%B6%D0%B5%D0%BD%D0%B5%D1%80%D0%B8%D0%BA%D0%B8-%D0%B8%D0%BD%D0%B2%D0%B0%D1%80%D0%B8%D0%B0%D0%BD%D1%82%D0%BD%D1%8B

92. Дано:
SortedSet<Entity> set = ...;
Найдите в jdk
1) тип 1, для которого SortedSet<Entity> является подтипом.
2) подтип 2 для SortedSet<Entity>.
Создайте множество set1 типа 1 и множество set2 подтипа 2. Проверьте правильность, сделав присваивания:
set1 = set;
set = set2;

93. Массивы и коллекции являются reified (овеществленные) или non-reified типами?
Поясните ответ.  
**Ответ.** Вторым важным отличием массивов от обобщенных типов является то, что массивы являются типами, доступными при выполнении (reified) [25, 4.7]. Это значит, что массивы знают тип элементов во время выполнения и обеспечивают его. Как было сказано ранее, попытавшись сохранить String в массив Long, вы получите исключение ArrayStoreException. Обобщенные типы, напротив, реализуются с использованием затирания (erasure) [25,4.6]. Это значит, что они обеспечивают ограничения на типы только на этапе компиляции, а затем отбрасывают (или затирают) информацию о типах элементов при выполнении. Затирание позволяет обобщенным типам свободно взаимодействовать со старым кодом, который не использует обобщенные типы (раздел 5.1), обеспечивая плавный переход к обобщенным типам в Java 5.
Соответственно: массивы - reified, всё остальное - нет.  
**Источник.** Дж.Блох, Java: эффективное программирование, 3-е изд.-169с.
